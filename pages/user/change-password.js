// API route 보호하기
// 만약 비번을 바꾸는 요청을 한다
// 인증된 사용자가 특정 API 라우트로 요청을 보내 특정 작업을 트리거 하는 방식이다
// 프로젝트에 특정 작업을 수행하는 API 라우트가 있고
// 해당 API 라우트에는 인증된 사용자가 보낸 요청인지 확인해야한다
// 사용자 인터페이스를 완벽하게 제한할 수 있다해도 다른 도구를 사용해 API 요청을 보낼 수 있기 때문이다
// 그러므로
// 요청의 유효성을 검사하고, 인증된 소스로부터의 요청인지 재확인하는 API 라우트도 보호해야한다
// 클라이언트 사이드 뿐 아니라 서버 사이드 API라우트도 중요한 것이다.

// 자체 API 경로를 만들 것이다
// 요청, 응답을 받는 핸들러 함수 생성

import {getSession} from "next-auth/react";

export default async function handler(req, res) {
  // 1. 올바른 요청이 들어오고 있는지 확인
  // 암호 변경, post, put patch 요청이 의미가 있는지 확인
  // 이것은 서버의 리소스를 생성하거나 변경해야함을 암시하는 3가지 유형의 요청이며
  // 암호 변경 = 새 암호를 생성한다고 설정
  // 들어오는 요청에 patch 메서드가 있는 경우에만 여기서 계속하고싶다고 말하기
  if(req.method !== 'PATCH') {
    return;
  }
  // 2. 인증된 사용자로부터 요청이 왔는지
  // 세션이 있는지 확인
  // getSession에는 서버 측에서 여기에서 받는 요청에 대한 req 키를 설정하는 개체 전달
  // getSession은 요청을 조사해 세션 토큰 쿠키가 요청의 일부인지 확인하기때문에
  // 들어오는 요청이 필요하다 -> 쿠키에서 데이터 유효성 검사, 추출한 다음
  // 의미가 있는 경우 세션 개체를 제공한다!
  const session = await getSession({req: req})
  if (!session) {
    res.status(401).json({message: '인증된 사용자가 아닙니다.'})
    return
  }
}